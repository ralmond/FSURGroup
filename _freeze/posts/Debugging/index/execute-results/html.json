{
  "hash": "64cf85106a632222581be339a2bb9900",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Debugging Strategies\"\nauthor: \"Russell Almond\"\ncategories: [debugging]\n---\n\n\n# Writing Test Cases\n\n## Setup inputs and expected outputs\n\nOften use a sequence here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:12,3,4)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n\n\n:::\n:::\n\nTest whether I got row/columns right in apply\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(mat,1,sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 22 26 30\n```\n\n\n:::\n\n```{.r .cell-code}\napply(mat,2,sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 15 24 33\n```\n\n\n:::\n:::\n\n\n## Using `stopifnot`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry(stopifnot(length(apply(mat,2,sum)==3L)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError : length(apply(mat, 2, sum) == 3L) is not TRUE\n```\n\n\n:::\n:::\n\n(The `try()` is necessary to keep quarto from stopping when the error occurs.  In general, we want the script to stop when if finds an error.)\n\n\n`all.equal` is useful here\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(apply(mat,1,sum),c(22,26,30))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\nAlternative is `all(apply(mat,1,sum)==c(22,26,30))`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(list(a=1,b=2),list(a=1,b=\"two\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Component \\\"b\\\": Modes: numeric, character\"              \n[2] \"Component \\\"b\\\": target is numeric, current is character\"\n```\n\n\n:::\n:::\n\n\"Epsilon\" is the biggest number such that $1+\\epsilon \\approx 1$.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.Machine$double.eps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.220446e-16\n```\n\n\n:::\n\n```{.r .cell-code}\ntol <- sqrt(.Machine$double.eps)\ntol\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.490116e-08\n```\n\n\n:::\n:::\n\nTo compare two doubles, subtract, then check that abs < tolerance\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstopifnot(all(abs(apply(mat,1,sum)-c(22,26,30)) < tol))\n```\n:::\n\nCould also use `all.equal(target, current, tolerance=tol)`\n\nSometimes need to wrap this in `isTRUE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntry({if (all.equal(c(22,26,30),apply(mat,2,sum))) {\n  print(\"Yattah!\")\n} else {\n  print(\"Gomen nasai!\")\n}})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError in if (all.equal(c(22, 26, 30), apply(mat, 2, sum))) { : \n  argument is not interpretable as logical\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nif (isTRUE(all.equal(c(22,26,30),apply(mat,2,sum)))) {\n  print(\"Yattah!\")\n} else {\n  print(\"Gomen nasai!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Gomen nasai!\"\n```\n\n\n:::\n:::\n\n\nBetter to use `{}` with `if`, `for`, `while`, as you may want to add debugging statements in between.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfun <- function(mat) {\n  rowsum <- apply(mat,2,sum)\nif (isTRUE(all.equal(c(22,26,30),rowsum))) {\n  print(\"Yattah!\")\n} else {\n  print(\"Gomen nasai!\")\n  recover()\n}\n}\nmyfun(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Gomen nasai!\"\nrecover called non-interactively; frames dumped, use debugger() to view\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfun <- function(mat) {\n  rowsum <- apply(mat,2,sum)\nif (isTRUE(all.equal(c(22,26,30),rowsum))) {\n  print(\"Yattah!\")\n} else {\n  print(\"Gomen nasai!\")\n}\n}\n```\n:::\n\n\n\n## Using `test_that`\n\n# Some things to try\n\n## Requesting Stack Traces\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(x) { print(1); bar(2) }\nbar <- function(x) { x + a.variable.which.does.not.exist }\ntry(foo(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\nError in bar(2) : object 'a.variable.which.does.not.exist' not found\n```\n\n\n:::\n:::\n\n\n## Check the inputs\n\n## Check the input order\n\nCheck the order of arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(myfun)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (mat) \nNULL\n```\n\n\n:::\n:::\n\n\n\n## Adding Print Statements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyfun <- function(mat) {\n  rowsum <- apply(mat,2,sum)\n  print(rowsum)\nif (isTRUE(all.equal(c(22,26,30),rowsum))) {\n  print(\"Yattah!\")\n} else {\n  print(\"Gomen nasai!\")\n}\n}\nmyfun(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 15 24 33\n[1] \"Gomen nasai!\"\n```\n\n\n:::\n:::\n\n\n## Adding Logging\n\n## `recover()`\n\n`options(error=recover)` will fall into debugger when the error occurs.\n\n\n### RStudio environment tab\n\n## traceing\n\n## The RStudio debugger\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}